.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "VMIPS 1"
.TH VMIPS 1 "2018-08-20" "vmips 1.5.1" "VMIPS Programmer's Manual"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
vmips \- VMIPS R3000\-based MIPS simulator (running and customizing)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        vmips [\-n] [\-F FILE] [\-o option_string] ... rom_file
\&        vmips \-\-help
\&        vmips \-\-version
\&        vmips \-\-print\-config
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When you invoke vmips, it loads a \s-1ROM\s0 file specified on the command line,
initializes and resets the \s-1MIPS\s0 processor, and begins execution at the first
address of the \s-1ROM\s0 file, which is normally loaded at address 0xbfc00000.
.SH "OPTIONS"
.IX Header "OPTIONS"
This is what the different command line options mean:
.IP "\fB\-F \s-1FILE\s0\fR" 4
.IX Item "-F FILE"
Read options from \s-1FILE\s0 instead of the \fI.vmipsrc\fR in your home directory.
.IP "\fB\-n\fR" 4
.IX Item "-n"
Do not read the system-wide configuration file, usually called
\&\fI/usr/local/etc/vmipsrc\fR.
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Prints a short summary of \s-1VMIPS\s0 command line options, and exits
successfully.
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
Prints a short summary of \s-1VMIPS\s0 version and copyright information,
and exits successfully.
.IP "\fB\-\-print\-config\fR" 4
.IX Item "--print-config"
Prints a short summary of \s-1VMIPS\s0 compile-time configuration information,
and exits successfully.
.IP "\fB\-o something\fR" 4
.IX Item "-o something"
Set the option \*(L"something\*(R" as if \*(L"something\*(R" were in your
\&.vmipsrc file.  See the \*(L"\s-1VMIPS\s0 options\*(R" section of the
\&\*(L"Customizing\*(R" chapter for more information on what kind
of things can go in your .vmipsrc file. You can use as many
\&\-o options on the command line as your shell will let you.
.IP "\fBrom_file\fR" 4
.IX Item "rom_file"
Use the named file as the \s-1ROM\s0 file \s-1VMIPS\s0 should boot. This
option is mandatory.
.SH "FILES"
.IX Header "FILES"
.SS "\s-1VMIPS\s0 options"
.IX Subsection "VMIPS options"
The \s-1VMIPS\s0 simulator gets runtime options from four different sources,
in this order: first, it checks its compile-time defaults, which are
set by the site administrator in the source file \fIoptiontbl.h\fR. Then,
the system-wide configuration file is read, unless you specify the \fB\-n\fR
option; usually this file is called
\&\fI/usr/local/etc/vmipsrc\fR, but it may have been moved by the site
administrator or by the maintainers of your distribution.
(This is configurable in the source file \fIoptions.h\fR, and
by specifying the \-\-prefix and \-\-sysconfdir options to the \s-1GNU
\&\s0\fBconfigure\fR
script when building \s-1VMIPS.\s0) Next, it checks the user's own configuration
file, usually the file \fI.vmipsrc\fR in your home directory, or whatever
file you specify using the \fB\-F\fR option. Last, it
reads the command line, and gets any options listed there.
.SS "Format of the configuration file"
.IX Subsection "Format of the configuration file"
The configuration file may contain as many options per line as you want,
provided no single line exceeds 1,024 characters in length.  Whitespace
separates options from one another.  Single quotes and backslash are valid
in the configuration file. Their meanings are similar to those found in
the Bourne shell: any text within paired single quotes is uninterpreted,
as is any character immediately following a backslash.  A comment is
any text starting from a hash mark to the end of the line, inclusive.
.PP
A string or number option named \s-1NAME\s0 can appear as NAME=VALUE, where \s-1VALUE\s0
is the string or number in question.  If the number begins with 0x, it will
be interpreted as a 32\-bit hexadecimal number, and if it begins with 0,
it will be interpreted as octal. Otherwise, it will be interpreted as a
decimal number. Numbers are always unsigned. A Boolean option named \s-1NAME\s0
can appear as either \s-1NAME \s0(to set it to \s-1TRUE\s0) or noNAME (to set it to \s-1FALSE\s0).
.SS "Summary of configuration options"
.IX Subsection "Summary of configuration options"
The following is a list of the configuration options present in this
version of \s-1VMIPS.\s0
.PP
\&\fBhaltdumpcpu\fR (type: Boolean)
.PP
.Vb 3
\& Controls whether the CPU registers and stack will be dumped
\&on halt. For the output format, please see the description of the
\&B<dumpcpu> option, below.  The default value is FALSE.
.Ve
.PP
\&\fBhaltdumpcp0\fR (type: Boolean)
.PP
.Vb 4
\& Controls whether the system control coprocessor (CP0) registers
\&and the contents of the translation lookaside buffer (TLB) will be
\&dumped on halt. For the output format, please see the description
\&of the B<dumpcp0> option, below.  The default value is FALSE.
.Ve
.PP
\&\fBexcpriomsg\fR (type: Boolean)
.PP
.Vb 4
\& Controls whether exception prioritizing messages will
\&be printed.  These messages attempt to explain which of
\&a number of exceptions caused by the same instruction
\&will be reported.  The default value is FALSE.
.Ve
.PP
\&\fBexcmsg\fR (type: Boolean)
.PP
.Vb 9
\& Controls whether every exception will cause a message
\&to be printed. The message gives the exception code, a
\&short explanation of the exception code, its priority,
\&the delay slot state of the virtual CPU, and states
\&what type of memory access the exception was caused by,
\&if applicable. Interrupt exceptions are only printed if
\&B<reportirq> is also set; when they occur, they also have Cause
\&and Status register information printed. TLB misses will have fault
\&address and user/kernel mode information printed.  The default value is FALSE.
.Ve
.PP
\&\fBbootmsg\fR (type: Boolean)
.PP
.Vb 3
\& Controls whether boot\-time and halt\-time messages will be printed.
\&These include ROM image size, self test messages, reset and halt
\&announcements, and possibly other messages.  The default value is TRUE.
.Ve
.PP
\&\fBinstdump\fR (type: Boolean)
.PP
.Vb 2
\& Controls whether every instruction executed will be disassembled
\&and printed.  The default value is FALSE. The output is in the following format:
\&        
\&        PC=0xbfc00000 [1fc00000]    24000000 li $zero,0
.Ve
.PP
The first column contains the \s-1PC \s0(program counter), followed by
the physical translation of that address in brackets. The third
column contains the machine instruction word at that address,
followed by the assembly language corresponding to that word.
All of the constants except for the assembly language are in
hexadecimal.
.PP
\&\fBdumpcpu\fR (type: Boolean)
.PP
.Vb 2
\& Controls whether the CPU registers and stack will be dumped after every
\&instruction.  The default value is FALSE. The output is in the following format:
\&        
\&        Reg Dump: [ PC=bfc00180  LastInstr=0000000d  HI=00000000  LO=00000000
\&                    DelayState=NORMAL  DelayPC=bfc00308  NextEPC=bfc00308
\&         R00=00000000  R01=00000000  R02=00000000  R03=a00c000e  R04=0000000a 
\&         ...
\&         R30=00000000  R31=bfc00308  ]
\&        Stack: 00000000 00000000 00000000 00000000 a2000008 a2000008 ...
.Ve
.PP
(Some values have been omitted for brevity.)
Here, \s-1PC\s0 is the program counter, LastInstr is the last instruction
executed, \s-1HI\s0 and \s-1LO\s0 are the multiplication/division result registers,
DelayState and DelayPC are used in delay slot processing, NextEPC
is what the Exception \s-1PC\s0 would be if an exception were to occur, and
R00 ... R31 are the \s-1CPU\s0 general purpose registers. Stack represents
the top few words on the stack.  All values are in hexadecimal.
.PP
\&\fBdumpcp0\fR (type: Boolean)
.PP
.Vb 4
\& Controls whether the system control coprocessor (CP0)
\&registers and the contents of the translation lookaside buffer
\&(TLB) will be dumped after every instruction.   The default value is FALSE.
\&The output is in the following format:
\&        
\&        CP0 Dump Registers: [        R00=00000000  R01=00003200 
\&         R02=00000000  R03=00000000  R04=001fca10  R05=00000000 
\&         R06=00000000  R07=00000000  R08=7fb7e0aa  R09=00000000 
\&         R10=00000000  R11=00000000  R12=00485e60  R13=f0002124 
\&         R14=bfc00308  R15=0000703b ]
\&        Dump TLB: [
\&        Entry 00: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        Entry 01: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        Entry 02: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        Entry 03: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        Entry 04: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        Entry 05: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        ...
\&        Entry 63: (00000fc000000000) V=00000 A=3f P=00000 ndvg
\&        ]
.Ve
.PP
Each of the R00 .. R15 are coprocessor zero registers, in
hexadecimal.  The Entry 00 .. 63 lines are \s-1TLB\s0 entries. The 64\-bit
number in parentheses is the hexadecimal raw value of the entry. V
is the virtual page number. A is the \s-1ASID. P\s0 is the physical page
number. \s-1NDVG\s0 are the Non-cacheable, Dirty, Valid, and Global bits,
uppercase if on, lowercase if off.
.PP
\&\fBhaltibe\fR (type: Boolean)
.PP
.Vb 7
\& If B<haltibe> is set to TRUE, the virtual machine will halt
\&after an instruction fetch causes a bus error (exception
\&code 6, Instruction bus error). This is useful if you
\&are expecting execution to jump to nonexistent addresses in
\&memory, and you want it to stop instead of calling the
\&exception handler.  It is important to note that the machine
\&halts after the exception is processed.  The default value is TRUE.
.Ve
.PP
\&\fBhaltbreak\fR (type: Boolean)
.PP
.Vb 5
\& If B<haltbreak> is set to TRUE, the virtual machine will halt
\&when a breakpoint exception is encountered (exception
\&code 9). This is equivalent to halting when a C<break>
\&instruction is encountered. It is important to note that the
\&machine halts after the breakpoint exception is processed.  The default value is TRUE.
.Ve
.PP
\&\fBhaltdevice\fR (type: Boolean)
.PP
.Vb 2
\& If B<haltdevice> is set to TRUE, the halt device is mapped into
\&physical memory, otherwise it is not.  The default value is TRUE.
.Ve
.PP
\&\fBinstcounts\fR (type: Boolean)
.PP
.Vb 5
\& Set B<instcounts> to TRUE if you want to see instruction
\&counts, a rough estimate of total runtime, and execution
\&speed in instructions per second when the virtual
\&machine halts.  The default value is FALSE.  The output is printed
\&at the end of the run, and is in the following format:
\&        
\&        7337 instructions in 0.0581 seconds (126282.271 instructions per second)
.Ve
.PP
\&\fBromfile\fR (type: string)
.PP
.Vb 4
\& This is the name of the file which will be initially
\&loaded into memory (at the address given in B<loadaddr>,
\&typically 0xbfc00000) and executed when the virtual
\&machine is reset.  The default value is "romfile.rom".
.Ve
.PP
\&\fBloadaddr\fR (type: number)
.PP
.Vb 9
\& This is the virtual address where the ROM will be loaded.
\&Note that the MIPS reset exception vector is always 0xbfc00000
\&so unless you\*(Aqre doing something incredibly clever you should
\&plan to have some executable code at that address. Since the
\&caches and TLB are in an indeterminate state at the time of
\&reset, the load address must be in uncacheable memory which
\&is not mapped through the TLB (kernel segment "kseg1"). This
\&effectively constrains the valid range of load addresses to
\&between 0xa0000000 and 0xc0000000.  The default value is 0xbfc00000.
.Ve
.PP
\&\fBmemsize\fR (type: number)
.PP
.Vb 2
\& This variable controls the size of the virtual CPU\*(Aqs "physical"
\&memory in bytes.  The default value is 0x100000.
.Ve
.PP
\&\fBmemdump\fR (type: Boolean)
.PP
.Vb 3
\& If B<memdump> is set, then the virtual machine will dump its RAM
\&into a file, whose name is given by the B<memdumpfile> option,
\&at the end of the simulation run.  The default value is FALSE.
.Ve
.PP
\&\fBmemdumpfile\fR (type: string)
.PP
.Vb 2
\& This is the name of the file to which a RAM dump will be
\&written at the end of the simulation run.  The default value is "memdump.bin".
.Ve
.PP
\&\fBreportirq\fR (type: Boolean)
.PP
.Vb 4
\& If B<reportirq> is set, then any change in the interrupt
\&inputs from a device will be reported on stderr. Also, any
\&Interrupt exception will be reported, if B<excmsg> is also
\&set.  The default value is FALSE.
.Ve
.PP
\&\fBspimconsole\fR (type: Boolean)
.PP
.Vb 2
\& When set, configure the SPIM\-compatible console device.
\&This is incompatible with B<decserial>.  The default value is TRUE.
.Ve
.PP
\&\fBttydev\fR (type: string)
.PP
.Vb 8
\& This pathname will be used as the device from which reads from the
\&SPIM\-compatible console device\*(Aqs Keyboard 1 will take their data, and
\&to which writes to Display 1 will send their data. If the OS supports
\&ttyname(3), that call will be used to guess the default pathname.
\&If the pathname is the single word B<off>, then the device will be
\&disconnected.
\&If the pathname is the single word B<stdout>, then the device
\&will be connected to standard output, and input will be disabled.  The default value is "/dev/tty".
.Ve
.PP
\&\fBttydev2\fR (type: string)
.PP
.Vb 2
\& See B<ttydev> option; this one is just like it, but pertains
\&to Keyboard 2 and Display 2.   The default value is "off".
.Ve
.PP
\&\fBdebug\fR (type: Boolean)
.PP
.Vb 5
\& If debug is set, then the gdb remote serial protocol backend will
\&be enabled in the virtual machine. This will cause the machine to
\&wait for gdb to attach and B<continue> before booting the ROM file.
\&If debug is not set, then the machine will boot the ROM file
\&without pausing.  The default value is FALSE.
.Ve
.PP
\&\fBdebugport\fR (type: number)
.PP
.Vb 2
\& If debugport is set to something nonzero, then the gdb remote
\&serial protocol backend will use the specified TCP port.  The default value is 0.
.Ve
.PP
\&\fBrealtime\fR (type: Boolean)
.PP
.Vb 4
\& If B<realtime> is set, then the clock device will cause simulated
\&time to run at some fraction of real time, determined by the
\&B<timeratio> option. If realtime is not set, then simulated time
\&will run at the speed given by the B<clockspeed> option.   The default value is FALSE.
.Ve
.PP
\&\fBtimeratio\fR (type: number)
.PP
.Vb 3
\& If the B<realtime> option is set, this option gives the
\&number of times slower than real time at which simulated time will
\&run. It has no effect if B<realtime> is not set.  The default value is 1.
.Ve
.PP
\&\fBclockspeed\fR (type: number)
.PP
.Vb 9
\& If the B<realtime> option is not set, you should set this
\&option to the average speed in MIPS instructions per second at which
\&your system runs VMIPS. You can get suitable values from turning
\&on the B<instcounts> option and running some of your favorite
\&programs. If you increase the value of B<clockspeed>, time will
\&appear to pass more slowly for the simulated machine; if you decrease
\&it, time will pass more quickly. (To be precise, one instruction is
\&assumed to take 1.0e9/B<clockspeed> nanoseconds.) This option
\&has no effect if B<realtime> is set.  The default value is 250000.
.Ve
.PP
\&\fBclockintr\fR (type: number)
.PP
.Vb 3
\& This option gives the frequency of clock interrupts, in nanoseconds
\&of simulated time, for the clock device. It does not affect the
\&DECstation\-compatible realtime clock.  The default value is 200000000.
.Ve
.PP
\&\fBclockdeviceirq\fR (type: number)
.PP
.Vb 3
\& This option gives the interrupt line to which the clock device is
\&connected. Values must be a number 2\-7 corresponding to an interrupt
\&line reserved for use by hardware.  The default value is 7.
.Ve
.PP
\&\fBclockdevice\fR (type: Boolean)
.PP
.Vb 2
\& If this option is set, then the clock device is enabled. This will
\&allow MIPS programs to take advantage of a high precision clock.  The default value is TRUE.
.Ve
.PP
\&\fBdbemsg\fR (type: Boolean)
.PP
.Vb 2
\& If this option is set, then the physical addresses of accesses
\&that cause data bus errors (DBE exceptions) will be printed.  The default value is FALSE.
.Ve
.PP
\&\fBdecrtc\fR (type: Boolean)
.PP
.Vb 2
\& If this option is set, then the DEC RTC device will be
\&configured.  The default value is FALSE.
.Ve
.PP
\&\fBdeccsr\fR (type: Boolean)
.PP
.Vb 2
\& If this option is set, then the DEC CSR (Control/Status Register)
\&will be configured.  The default value is FALSE.
.Ve
.PP
\&\fBdecstat\fR (type: Boolean)
.PP
.Vb 2
\& If this option is set, then the DEC CHKSYN and ERRADR registers
\&will be configured.  The default value is FALSE.
.Ve
.PP
\&\fBdecserial\fR (type: Boolean)
.PP
.Vb 2
\& If this option is set, then the DEC DZ11 serial device
\&will be configured. This is incompatible with B<spimconsole>.  The default value is FALSE.
.Ve
.PP
\&\fBtracing\fR (type: Boolean)
.PP
.Vb 4
\& If this option is set, VMIPS will keep a trace of the last few
\&instructions executed in memory, and write it out when the machine
\&halts.  This incurs a substantial performance penalty.  Use the
\&B<tracesize> option to set the size of the trace you want.  The default value is FALSE.
.Ve
.PP
\&\fBtracesize\fR (type: number)
.PP
.Vb 3
\& Set this option to the maximum number of instructions to keep in the
\&dynamic instruction trace. This has no effect if B<tracing> is
\&not set.  The default value is 100000.
.Ve
.PP
\&\fBbigendian\fR (type: Boolean)
.PP
.Vb 7
\& If this option is set, then the emulated MIPS CPU will be in
\&Big\-Endian mode.  Otherwise, it will be in Little\-Endian mode. You
\&must set it to correspond to the type of binaries that your
\&assembler and compiler are configured to produce, which is not
\&necessarily the same as the endianness of the CPU on which you
\&are running VMIPS.  (The default may not be meaningful for your
\&setup!)  The default value is FALSE.
.Ve
.PP
\&\fBtracestartpc\fR (type: number)
.PP
.Vb 2
\& If the tracing option is set, then this is the PC value which will
\&trigger the start of tracing.  Otherwise it has no effect.  The default value is 0.
.Ve
.PP
\&\fBtraceendpc\fR (type: number)
.PP
.Vb 2
\& If the tracing option is set, then this is the PC value which will
\&trigger the end of tracing. Otherwise it has no effect.  The default value is 0.
.Ve
.PP
\&\fBmipstoolprefix\fR (type: string)
.PP
.Vb 8
\& vmipstool uses this option to locate your MIPS\-targetted cross
\&compilation tools, if you have them installed. If your MIPS GCC
\&is installed as /opt/mips/bin/mips\-elf\-gcc, then you should set
\&this option to "/opt/mips/bin/mips\-elf\-". vmipstool looks for
\&the "gcc", "ld", "objcopy" and "objdump" programs starting with
\&this prefix. This option should be set in your installed
\&system\-wide VMIPS configuration file (vmipsrc) by the "configure"
\&script; the compiled\-in default is designed to cause an error.  The default value is "/nonexistent/mips/bin/mipsel\-ecoff\-".
.Ve
.PP
\&\fBexecname\fR (type: string)
.PP
.Vb 6
\& Name of executable to be loaded by automatic kernel loader. This
\&is an experimental, unfinished feature. The option value
\&must be the name of a MIPS ECOFF executable file, or \*(Aqnone\*(Aq
\&to disable the option.  The executable\*(Aqs headers must specify
\&load addresses in KSEG0 or KSEG1 (0x80000000 through
\&0xbfffffff).   The default value is "none".
.Ve
.PP
\&\fBfpu\fR (type: Boolean)
.PP
.Vb 4
\& True to enable hooks in the CPU to communicate with a
\&floating\-point unit as coprocessor 1. The floating\-point unit
\&is not implemented; only the hooks in the CPU are. This is an
\&experimental, unfinished feature.  The default value is FALSE.
.Ve
.PP
\&\fBtestdev\fR (type: Boolean)
.PP
.Vb 4
\& True to enable a memory\-mapped device that is used to test
\&the memory\-mapped device interface. The VMIPS test suite turns
\&this device on as necessary; you should not normally need
\&to enable it.  The default value is FALSE.
.Ve
.SH "BUGS"
.IX Header "BUGS"
For instructions on reporting bugs, see
the \*(L"Reporting Bugs\*(R" appendix of the Info manual.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIas\fR\|(1), \fIld\fR\|(1), \fIgdb\fR\|(1), 
and the Info entries for \fIvmips\fR, \fIgcc\fR, \fIas\fR,
\&\fIld\fR, \fIbinutils\fR and \fIgdb\fR.
.PP
Important: The information in this man page is an extract from the full
documentation of the \s-1VMIPS\s0 simulator, and is limited to the meaning of
the command-line options. If you didn't find what you were looking for here,
or you want more information, please refer to the Info file \fIvmips\fR
or the \s-1VMIPS\s0 Programmer's Manual.  Both are made from the Texinfo source
file vmips.texi.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1VMIPS\s0 was written by Brian Gaeke.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001, 2002, 2004, 2009, 2014 Brian R. Gaeke.
.PP
Permission is hereby granted, free of charge, to any person obtaining a
copy of this document (the \*(L"Document\*(R"), to deal in the Document without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of
the Document, and to permit persons to whom the Document is furnished
to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Document.
.PP
\&\s-1THE DOCUMENT IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE DOCUMENT OR THE USE OR OTHER DEALINGS IN THE
DOCUMENT.\s0
